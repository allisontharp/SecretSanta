import { ReflectiveInjector, Component, ComponentFactoryResolver, ViewChild, ViewContainerRef, Injectable, ApplicationRef, Injector, Optional, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Observable } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dialog-wrapper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DialogWrapperComponent {
    /**
     * Constructor
     * @param {?} resolver resolver
     * @param {?} dialogService dialogService
     */
    constructor(resolver, dialogService) {
        this.resolver = resolver;
        this.dialogService = dialogService;
    }
    /**
     * Adds content dialog component to wrapper
     * @template T, T1
     * @param {?} component component
     * @param {?=} customFactory customFactory
     * @return {?} DialogComponent
     */
    addComponent(component, customFactory) {
        /** @type {?} */
        const factory = customFactory || this.resolver.resolveComponentFactory(component);
        /** @type {?} */
        const injector = ReflectiveInjector.fromResolvedProviders([], this.element.injector);
        /** @type {?} */
        const componentRef = factory.create(injector);
        this.element.insert(componentRef.hostView);
        this.content = (/** @type {?} */ (componentRef.instance));
        this.content.wrapper = this;
        return this.content;
    }
    /**
     * Registers event handler to close dialog by click on backdrop
     * @return {?}
     */
    closeByClickOutside() {
        /** @type {?} */
        const containerEl = this.container.nativeElement;
        containerEl.querySelector('.modal-content').addEventListener('click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.stopPropagation();
        }));
        containerEl.addEventListener('click', (/**
         * @return {?}
         */
        () => {
            this.dialogService.removeDialog(this.content);
        }), false);
    }
}
DialogWrapperComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'dialog-wrapper',
                template: `
      <div #container class="modal fade" style="display:block !important;" role="dialog">
          <ng-template #element></ng-template>
      </div>
  `
            }] }
];
/** @nocollapse */
DialogWrapperComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: DialogService }
];
DialogWrapperComponent.propDecorators = {
    element: [{ type: ViewChild, args: ['element', { static: true, read: ViewContainerRef },] }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }]
};
if (false) {
    /**
     * Target element to insert dialog content component
     * @type {?}
     */
    DialogWrapperComponent.prototype.element;
    /**
     * Link container DOM element
     * @type {?}
     */
    DialogWrapperComponent.prototype.container;
    /**
     * Dialog content componet
     * @type {?}
     * @private
     */
    DialogWrapperComponent.prototype.content;
    /**
     * @type {?}
     * @private
     */
    DialogWrapperComponent.prototype.resolver;
    /**
     * @type {?}
     * @private
     */
    DialogWrapperComponent.prototype.dialogService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dialog-holder.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DialogHolderComponent {
    /**
     * Constructor
     * @param {?} resolver ComponentFactoryResolver
     */
    constructor(resolver) {
        this.resolver = resolver;
        /**
         * Array of dialogs
         */
        this.dialogs = [];
    }
    /**
     * Adds dialog
     * @template T, T1
     * @param {?} component Type<DialogComponent>
     * @param {?=} data object?
     * @param {?=} options DialogOptions?
     * @return {?} Observable<*>
     */
    addDialog(component, data, options) {
        options = options || (/** @type {?} */ ({}));
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(DialogWrapperComponent);
        /** @type {?} */
        const componentRef = this.element.createComponent(factory, options.index);
        /** @type {?} */
        const dialogWrapper = (/** @type {?} */ (componentRef.instance));
        // tslint:disable-next-line:variable-name
        /** @type {?} */
        const _component = dialogWrapper.addComponent(component, options.customFactory);
        if (typeof (options.index) !== 'undefined') {
            this.dialogs.splice(options.index, 0, _component);
        }
        else {
            this.dialogs.push(_component);
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            dialogWrapper.container.nativeElement.classList.add('show');
            dialogWrapper.container.nativeElement.classList.add('in');
        }));
        if (options.autoCloseTimeout) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.removeDialog(_component);
            }), options.autoCloseTimeout);
        }
        if (options.closeByClickingOutside) {
            dialogWrapper.closeByClickOutside();
        }
        if (options.backdropColor) {
            dialogWrapper.container.nativeElement.style.backgroundColor = options.backdropColor;
        }
        return _component.fillData(data);
    }
    /**
     * Removes dialog
     * @param {?} component DialogComponent
     * @return {?}
     */
    removeDialog(component) {
        /** @type {?} */
        const element = component.wrapper.container.nativeElement;
        element.classList.remove('show');
        element.classList.remove('in');
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._removeElement(component);
        }), 300);
    }
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    _removeElement(component) {
        /** @type {?} */
        const index = this.dialogs.indexOf(component);
        if (index > -1) {
            this.element.remove(index);
            this.dialogs.splice(index, 1);
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.element.clear();
        this.dialogs = [];
    }
}
DialogHolderComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'dialog-holder',
                template: '<ng-template #element></ng-template>'
            }] }
];
/** @nocollapse */
DialogHolderComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
DialogHolderComponent.propDecorators = {
    element: [{ type: ViewChild, args: ['element', { static: true, read: ViewContainerRef },] }]
};
if (false) {
    /**
     * Target element to insert dialogs
     * @type {?}
     */
    DialogHolderComponent.prototype.element;
    /**
     * Array of dialogs
     * @type {?}
     */
    DialogHolderComponent.prototype.dialogs;
    /**
     * @type {?}
     * @private
     */
    DialogHolderComponent.prototype.resolver;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dialog.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function DialogOptions() { }
if (false) {
    /** @type {?|undefined} */
    DialogOptions.prototype.index;
    /** @type {?|undefined} */
    DialogOptions.prototype.autoCloseTimeout;
    /** @type {?|undefined} */
    DialogOptions.prototype.closeByClickingOutside;
    /** @type {?|undefined} */
    DialogOptions.prototype.backdropColor;
    /** @type {?|undefined} */
    DialogOptions.prototype.customFactory;
}
class DialogServiceConfig {
    constructor() {
        this.container = null;
    }
}
if (false) {
    /** @type {?} */
    DialogServiceConfig.prototype.container;
}
class DialogService {
    /**
     * @param {?} resolver resolver
     * @param {?} applicationRef applicationRef
     * @param {?} injector injector
     * @param {?} config config
     */
    constructor(resolver, applicationRef, injector, config) {
        this.resolver = resolver;
        this.applicationRef = applicationRef;
        this.injector = injector;
        this.container = config && config.container;
    }
    /**
     * Adds dialog
     * @template T, T1
     * @param {?} component component
     * @param {?=} data data
     * @param {?=} options options
     * @return {?} Observable<T1>
     */
    addDialog(component, data, options) {
        if (!this.dialogHolderComponent) {
            this.dialogHolderComponent = this.createDialogHolder(options ? options.customFactory : null);
        }
        return this.dialogHolderComponent.addDialog(component, data, options);
    }
    /**
     * Hides and removes dialog from DOM
     * @param {?} component DialogComponent
     * @return {?}
     */
    removeDialog(component) {
        if (!this.dialogHolderComponent) {
            return;
        }
        this.dialogHolderComponent.removeDialog(component);
    }
    /**
     * Closes all dialogs
     * @return {?}
     */
    removeAll() {
        this.dialogHolderComponent.clear();
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const body = document.querySelector('body');
            if (body && body.classList) {
                body.classList.remove('modal-open');
            }
        }), 1);
    }
    /**
     * Creates and add to DOM dialog holder component
     * @private
     * @param {?=} customFactory
     * @return {?} DialogHolderComponent
     */
    createDialogHolder(customFactory) {
        /** @type {?} */
        let componentFactory = null;
        if (customFactory) {
            componentFactory = customFactory;
        }
        else {
            componentFactory = this.resolver.resolveComponentFactory(DialogHolderComponent);
        }
        /** @type {?} */
        const componentRef = componentFactory.create(this.injector);
        /** @type {?} */
        const componentRootNode = (/** @type {?} */ (((/** @type {?} */ (componentRef.hostView))).rootNodes[0]));
        if (!this.container) {
            /** @type {?} */
            const componentRootViewContainer = this.applicationRef.components[0];
            this.container = (/** @type {?} */ (((/** @type {?} */ (componentRootViewContainer.hostView))).rootNodes[0]));
        }
        this.applicationRef.attachView(componentRef.hostView);
        componentRef.onDestroy((/**
         * @return {?}
         */
        () => {
            this.applicationRef.detachView(componentRef.hostView);
        }));
        this.container.appendChild(componentRootNode);
        return componentRef.instance;
    }
}
DialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DialogService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: DialogServiceConfig, decorators: [{ type: Optional }] }
];
if (false) {
    /**
     * Placeholder of modal dialogs
     * @type {?}
     * @private
     */
    DialogService.prototype.dialogHolderComponent;
    /**
     * HTML container for dialogs
     * type {HTMLElement}
     * @type {?}
     * @private
     */
    DialogService.prototype.container;
    /**
     * @type {?}
     * @private
     */
    DialogService.prototype.resolver;
    /**
     * @type {?}
     * @private
     */
    DialogService.prototype.applicationRef;
    /**
     * @type {?}
     * @private
     */
    DialogService.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngm-bootstrap-modal.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Dialog service factory. Creates dialog service with options
 * @param {?} resolver ComponentFactoryResolver
 * @param {?} applicationRef ApplicationRef
 * @param {?} injector Injector
 * @param {?} options DialogServiceConfig
 * @return {?} DialogService
 */
function dialogServiceFactory(resolver, applicationRef, injector, options) {
    return new DialogService(resolver, applicationRef, injector, options);
}
class NgmBootstrapModalModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: NgmBootstrapModalModule,
            providers: [
                { provide: DialogServiceConfig, useValue: config },
                {
                    provide: DialogService,
                    useFactory: dialogServiceFactory,
                    deps: [ComponentFactoryResolver, ApplicationRef, Injector, DialogServiceConfig]
                }
            ]
        };
    }
}
NgmBootstrapModalModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DialogHolderComponent,
                    DialogWrapperComponent
                ],
                providers: [
                    DialogService
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    DialogHolderComponent,
                    DialogWrapperComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dialog.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract dialog
 * @template T, T1
 */
class DialogComponent {
    /**
     * Constructor
     * @param {?} dialogService - instance of DialogService
     */
    constructor(dialogService) {
        this.dialogService = dialogService;
    }
    /**
     *
     * @param {?} data T
     * @return {?} Observable<T1>
     */
    fillData(data) {
        data = data || (/** @type {?} */ ({}));
        /** @type {?} */
        const keys = Object.keys(data);
        for (let i = 0, length = keys.length; i < length; i++) {
            /** @type {?} */
            const key = keys[i];
            this[key] = data[key];
        }
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.observer = observer;
            return (/**
             * @return {?}
             */
            () => {
                this.close();
            });
        }));
    }
    /**
     * Closes dialog
     * @return {?}
     */
    close() {
        this.dialogService.removeDialog(this);
    }
    /**
     * OnDestroy handler
     * Sends dialog result to observer
     * @return {?}
     */
    ngOnDestroy() {
        if (this.observer) {
            this.observer.next(this.result);
        }
    }
}
if (false) {
    /**
     * Observer to return result from dialog
     * @type {?}
     * @private
     */
    DialogComponent.prototype.observer;
    /**
     * Dialog result
     * @type {?}
     * @protected
     */
    DialogComponent.prototype.result;
    /**
     * Dialog wrapper (modal placeholder)
     * @type {?}
     */
    DialogComponent.prototype.wrapper;
    /**
     * @type {?}
     * @protected
     */
    DialogComponent.prototype.dialogService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngm-bootstrap-modal.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DialogComponent, DialogService, DialogServiceConfig, NgmBootstrapModalModule, dialogServiceFactory as ɵa, DialogHolderComponent as ɵb, DialogWrapperComponent as ɵc };
//# sourceMappingURL=ngm-bootstrap-modal.js.map
